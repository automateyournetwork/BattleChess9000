<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Mobile-friendly viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Battle Chess 9000</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        
        .ui-layer { position: absolute; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        #hud { top: 20px; }
        h1 { margin: 0; color: #fff; text-transform: uppercase; letter-spacing: 4px; font-size: 24px; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        #status { color: #aaa; margin-top: 5px; font-size: 16px; font-weight: bold; }
        #player-display { color: #444; font-size: 14px; margin-top: 5px; font-family: monospace; letter-spacing: 1px;}

        /* CHECK ALERT */
        #check-alert { 
            display: none; 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 100px; font-weight: 900; color: red; 
            text-shadow: 0 0 20px black; border: 5px solid red; padding: 20px 50px; 
            background: rgba(0,0,0,0.7); z-index: 500;
            animation: pulse-alert 0.5s infinite alternate;
            pointer-events: none;
        }
        @keyframes pulse-alert { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }

        /* CAPTURE TRACKER */
        .tracker { 
            position: absolute; top: 100px; width: 50px; bottom: 100px;
            display: flex; flex-direction: column; gap: 5px; padding: 10px; 
            pointer-events: none; z-index: 5;
        }
        .tracker-left { left: 10px; align-items: flex-start; }
        .tracker-right { right: 10px; align-items: flex-end; }
        
        .capture-icon { 
            width: 45px; height: 45px; object-fit: contain; 
            filter: drop-shadow(0 0 2px rgba(255,255,255,0.5));
            transition: transform 0.2s;
        }
        .capture-icon:hover { transform: scale(1.5); }

        /* MODALS */
        .modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); z-index: 2000; 
            display: none; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; overflow-y: auto;
        }
        .modal.active { display: flex; }

        .menu-box { 
            background: #1a1a1a; padding: 40px; border: 1px solid #333; 
            box-shadow: 0 0 50px rgba(0,0,0,1); text-align: center; border-radius: 8px;
            max-width: 500px; width: 90%;
            position: relative;
        }

        /* AVATAR GRID STYLES */
        .avatar-grid { 
            display: grid; 
            grid-template-columns: repeat(6, 1fr);
            gap: 8px; 
            margin: 15px 0;
            background: #111;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        .avatar-option { 
            background: #222; border: 2px solid #333; border-radius: 4px; padding: 2px; 
            cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center;
            aspect-ratio: 1 / 1;
        }
        .avatar-option:hover { border-color: #666; background: #333; }
        .avatar-option.selected { border-color: #28a745; background: #1a3a1a; box-shadow: 0 0 10px #28a745; }
        .avatar-option img { width: 100%; height: 100%; object-fit: contain; }

        /* LOBBY LIST */
        .player-list { 
            list-style: none; padding: 0; margin: 20px 0; 
            max-height: 250px; overflow-y: auto; border: 1px solid #333;
        }
        .player-item { 
            display: flex; align-items: center; justify-content: space-between; 
            padding: 10px; background: #222; border-bottom: 1px solid #333;
        }
        .player-item:hover { background: #333; }
        .player-info { display: flex; align-items: center; gap: 10px; text-align: left; }
        .player-stats { font-size: 11px; color: #888; display: block; }
        
        .challenge-btn { 
            width: auto; padding: 5px 15px; background: #4da6ff; border: none; 
            color: #000; font-weight: bold; font-size: 12px; cursor: pointer;
        }
        .challenge-btn:hover { background: #fff; }

        /* CHALLENGE POPUP */
        .challenge-alert {
            background: #4da6ff; color: #000; padding: 20px; border-radius: 8px;
            animation: pulse-alert 1s infinite;
        }      

        select, button, input[type="text"], .toggle-group { 
            display: block; width: 100%; padding: 10px; margin: 10px 0; box-sizing: border-box;
            font-size: 16px; background: #333; color: white; border: 1px solid #555; 
            cursor: pointer; 
        }
        input[type="text"] { cursor: text; text-align: center; font-weight: bold; border: 1px solid #444; }
        input[type="text"]:focus { outline: none; border-color: #28a745; }

        button { background: #444; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: #666; }
        
        /* Main Button Group */
        .main-actions { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .action-row { display: flex; gap: 10px; }
        .action-btn { flex: 1; border: none; }
        
        .promo-options { display: flex; gap: 20px; margin-top:20px; justify-content: center;}
        .promo-piece { 
            width: 60px; height: 60px; background: #333; border: 2px solid #555;
            display: flex; align-items: center; justify-content: center;
            font-size: 30px; cursor: pointer; color: #fff;
        }
        .promo-piece:hover { background: #555; border-color: white; }

        #battle-overlay { 
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: black; z-index: 1000;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        video { width: 100%; height: 80%; object-fit: contain; }
        #video-msg { color: #ff5555; font-family: monospace; font-size: 18px; margin-bottom: 20px; }
        #skip-btn { width: auto; display: inline-block; background: transparent; border: 2px solid white; margin-top: 20px; }
        #skip-btn:hover { background: white; color: black; }

        /* Invite Link Input */
        .link-box {
            background: #000; border: 1px solid #4da6ff; color: #4da6ff;
            padding: 10px; width: 100%; text-align: center; font-family: monospace;
            margin-bottom: 15px; cursor: pointer;
        }

        /* END GAME SCROLLABLE CONTENT */
        .endgame-content {
            max-height: 80vh;
            overflow-y: auto;
            text-align: left;
            padding-right: 10px;
        }
        .endgame-content::-webkit-scrollbar { width: 8px; }
        .endgame-content::-webkit-scrollbar-track { background: #111; }
        .endgame-content::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        .prompt-block {
            background: #000; border: 1px solid #333; padding: 15px; margin-bottom: 20px;
            font-family: monospace; font-size: 12px; color: #0f0; white-space: pre-wrap;
            text-align: left;
        }
        h3 { border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px; color: #ddd; }
        p { line-height: 1.6; color: #bbb; }
        .highlight { color: #fff; font-weight: bold; }
        a { color: #4da6ff; text-decoration: none; }
        a:hover { text-decoration: underline; }

        @media (max-width: 768px) {
            .menu-box { width: 95%; padding: 15px; max-height: 95vh; overflow-y: auto; }
            .avatar-grid { grid-template-columns: repeat(4, 1fr); }
            .tracker { flex-direction: row; width: 100%; height: 40px; top: auto; bottom: 10px; padding: 0; justify-content: center; gap: 5px; }
            .tracker-left { left: 0; bottom: 50px; align-items: center; }
            .tracker-right { right: 0; bottom: 10px; align-items: center; }
            .capture-icon { width: 35px; height: 35px; }
            #check-alert { font-size: 40px; width: 80%; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
</head>
<body>

    <!-- START MENU -->
    <div id="start-menu" class="modal active">
        <div class="menu-box">
            <h2 style="margin-top:0; margin-bottom: 5px;">BATTLE CHESS 9000</h2>
            <p style="color: #666; font-size: 13px; font-style: italic; margin-top: 0; margin-bottom: 20px;">
                "It's not just a game, it's a battle."
            </p>
            
            <input type="text" id="player-name-input" placeholder="ENTER YOUR NAME" maxlength="15">
            
            <label style="margin-top: 15px; color: #888; font-size: 14px;">Select Game Theme</label>
            <select id="theme-select" onchange="updateAvatarGrid()"><option disabled selected value="">Loading themes...</option></select>
            
            <label style="margin-top: 15px; color: #888; font-size: 14px;">Choose Avatar (From Selected Theme)</label>
            <div id="avatar-grid" class="avatar-grid"></div>
            
            <div class="main-actions">
                <div class="action-row">
                    <button onclick="joinLobby()" style="background:#4da6ff; color:black; flex:2;">ENTER ONLINE LOBBY</button>
                    <button onclick="createPrivateGame()" style="background:#8a2be2; color:white; flex:1;">INVITE LINK</button>
                </div>
                <div class="action-row">
                    <button class="action-btn" onclick="startGameAI()">VS AI (SOLO)</button>
                    <button class="action-btn" onclick="startGameLocal()">VS FRIEND (LOCAL)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- LOBBY MENU -->
    <div id="lobby-menu" class="modal">
        <div class="menu-box">
            <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #333; padding-bottom:10px; margin-bottom:10px;">
                <h2 style="margin:0;">LOBBY</h2>
                <button onclick="disconnectSocket()" style="width:auto; padding:5px 10px; font-size:12px; background:#444;">Exit</button>
            </div>
            
            <div style="display:flex; align-items:center; justify-content:center; gap:10px; margin-bottom:15px; background: #222; padding: 10px; border-radius: 4px;">
                <img id="my-avatar-display" src="" style="width:40px; height:40px; object-fit: contain;">
                <h3 id="my-name-display" style="margin:0; color:#28a745;"></h3>
            </div>

            <p style="text-align: left; color: #888; font-size: 12px; margin-bottom: 5px;">ONLINE COMMANDERS:</p>
            <ul id="lobby-list" class="player-list">
                <li style="padding:10px; color:#666;">Connecting to server...</li>
            </ul>
        </div>
    </div>

    <!-- INVITE LINK WAITING ROOM -->
    <div id="invite-menu" class="modal">
        <div class="menu-box">
            <h2 style="color: #8a2be2;">PRIVATE GAME</h2>
            <p>Share this link with your friend to start.</p>
            <input type="text" id="invite-link-box" class="link-box" readonly onclick="this.select(); document.execCommand('copy'); alert('Copied!')">
            <p style="font-size: 12px; color: #666;">Waiting for opponent to join...</p>
            <div class="action-row">
                <button onclick="disconnectSocket()" style="background:#444;">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- CHALLENGE POPUP -->
    <div id="challenge-modal" class="modal">
        <div class="menu-box challenge-alert">
            <h2>⚔️ CHALLENGE! ⚔️</h2>
            <p id="challenger-name">Player X wants to battle!</p>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button onclick="acceptChallenge()" style="background:white; color:black; flex:1;">ACCEPT</button>
                <button onclick="declineChallenge()" style="background:#222; color:white; flex:1;">DECLINE</button>
            </div>
        </div>
    </div>

    <!-- PROMOTION MENU -->
    <div id="promo-modal" class="modal">
        <div class="menu-box">
            <h2>Promote Pawn</h2>
            <div class="promo-options">
                <div class="promo-piece" onclick="commitPromotion('q')">♕</div>
                <div class="promo-piece" onclick="commitPromotion('r')">♖</div>
                <div class="promo-piece" onclick="commitPromotion('b')">♗</div>
                <div class="promo-piece" onclick="commitPromotion('n')">♘</div>
            </div>
        </div>
    </div>

    <!-- GAME OVER / INFO MODAL -->
    <div id="game-over-modal" class="modal">
        <div class="menu-box" style="width: 800px; max-width: 95%;">
            <div class="endgame-content">
                <h1 id="end-title" style="text-align: center; color: #28a745;">GAME OVER</h1>
                <p id="end-reason" style="text-align: center; font-size: 18px; margin-bottom: 30px;"></p>

                <div style="background: #222; padding: 20px; border-left: 4px solid #4da6ff; margin-bottom: 20px;">
                    <p style="margin-top:0; font-style: italic;">
                        "This game was fully vibe coded over an afternoon with <strong>Gemini-3, Nano Banana 3, and Veo3</strong> plus an API key."
                    </p>
                    <p>
                        Did you enjoy your Battle Chess experience? Did the animations live up to your expectations?
                    </p>
                    <p style="font-weight: bold; color: white;">
                        Please write up your experience in a Tweet, LinkedIn post, or Blog! Share with your kids, friends, and colleagues.
                    </p>
                </div>

                <h3>How It Was Made (The Prompts)</h3>
                <p>Want to fork this? Run the asset-generator in the repo and use these exact prompts to recreate this theme:</p>
                
                <p class="highlight">1. Theme Title:</p>
                <div class="prompt-block">medieval_classic</div>

                <p class="highlight">2. Board Style:</p>
                <div class="prompt-block">Medeival 1600s castles with white marble and black obsidian as classical a chessboard you can make with these matierals at the time. Do NOT display pieces just the board and its polished matierals of marble and black obsidian.</div>

                <p class="highlight">3. Piece Style:</p>
                <div class="prompt-block">"These are chess pieces in a set. Do not deviate from classic chess pieces but be creative. The Pawns should be peasants or orcs not just chess pawns. As with the rest of the pieces. 1600s medieval European style with White as holy good and Black as gothic evil, showing a noble crowned king, regal robed queen, Catholic bishops with mitres, armored knights on warhorses, fortified stone castle rooks, and simple foot-soldier pawns for White, versus a dark overlord king with spiked crown, sinister robed queen, corrupted plague-priest bishops, skeletal or demonic knights on shadow steeds, dragon-tower rooks with infernal accents, and ragged disposable pawns for Black, all rendered individually in hand-painted medieval illustration style with clear chess silhouettes, high detail, dramatic shading, parchment background, 1:1 aspect ratio, and consistent lighting. IMPORTANT use highly detailed white marble with gold accents for white pieces and black obsidian with dark silver accents for black pieces. They should be highly detailed and look like they were carved from those materials and polished to a high shine. DO NOT MAKE CARTOONS"</div>

                <p class="highlight">4. Animation Style:</p>
                <div class="prompt-block">"Create ultra-violent Excalibur-1980-style medieval fantasy battle animations showing chess pieces as armored warriors made of metal, bone, and enchanted stone brutally hacking, cleaving, crushing, and shattering each other during captures—for example pawns hacking down pawns, knights impaling pawns, rooks smashing queens, bishops cleaving rooks—rendered with hyper-stylized metallic blood-spray, glowing runic energy bursts, slow-motion sword impacts, shattered armor fragments, fog-soaked battle lighting, heavy chromatic bloom, mythic brutality, and the dark, operatic, blood-drenched tone of John Boorman’s Excalibur. IMPORTANT ALWAYS source the characters from the images do not change their appearance or style. These are medieval fantasy chess pieces NOT generic fantasy characters. DO NOT make cartoons or low detail images. Use highly detailed realistic textures and lighting. DO NOT use modern weapons or technology. ONLY the weapons the piece is holding."</div>

                <hr style="border-color: #333; margin: 30px 0;">

                <div style="text-align: center;">
                    <p><strong>Fork the Repo:</strong> <br> <a href="https://github.com/automateyournetwork/BattleChess9000" target="_blank">github.com/automateyournetwork/BattleChess9000</a></p>
                    <p><strong>Contact:</strong> <br> <a href="mailto:ptcapo@gmail.com">ptcapo@gmail.com</a></p>
                    <button onclick="location.reload()" style="margin-top: 20px;">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <div id="hud" class="ui-layer">
        <h1>Battle Chess AI</h1>
        <div id="player-display"></div>
        <div id="status">Waiting for game start...</div>
    </div>

    <div id="check-alert">CHECK!</div>
    <div id="tracker-w" class="tracker tracker-left"></div>
    <div id="tracker-b" class="tracker tracker-right"></div>

    <div id="battle-overlay">
        <div id="video-msg"></div>
        <video id="battle-video" playsinline></video>
        <button id="skip-btn">Skip Animation</button>
    </div>

    <script>
        // --- CONFIG & GLOBALS ---
        // Change this to ws://localhost:8080 if running server locally
        const WS_URL = "wss://battlechess9000-multiplayer-service-960937205198.us-central1.run.app"; 
        
        let CURRENT_THEME = '';
        let PLAYER_COLOR = 'w';
        let PLAYER_NAME = 'Guest';
        const BOARD_SQUARE_SIZE = 10;
        const BOARD_OFFSET = (8 * BOARD_SQUARE_SIZE) / 2 - (BOARD_SQUARE_SIZE / 2);
        let ASSETS_PATH = '';

        const game = new Chess();
        let socket = null;
        let myClientId = null;
        let currentRoomId = null;
        let selectedAvatar = 'w_k'; 
        let isMultiplayer = false;
        let isAIEnabled = false; 
        let isAIThinking = false;
        let pendingChallengeId = null;
        
        let selectedSquare = null;
        let selectedMesh = null;
        let pendingPromotionMove = null;

        const IN_PROGRESS_THEMES = ["super_mario_world", "justice_league_vs_legion_of_doom"];

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 40, 300);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 1.2);
        spotLight.position.set(30, 100, 30);
        spotLight.castShadow = true;
        scene.add(spotLight);

        const textureLoader = new THREE.TextureLoader();
        const piecesMap = {};
        const pieceCache = {};

        // --- INITIALIZATION ---
        window.onload = function() { 
            loadThemes().then(() => {
                // Check if invite link
                const urlParams = new URLSearchParams(window.location.search);
                const roomId = urlParams.get('room');
                if (roomId) {
                    joinPrivateGame(roomId);
                }
            });
        };

        function loadThemes() {
            return fetch('assets/themes.json')
                .then(r => {
                    if (!r.ok) throw new Error("Manifest not found");
                    return r.json();
                })
                .then(themes => {
                    const sel = document.getElementById('theme-select');
                    sel.innerHTML = '';
                    
                    if (!themes || themes.length === 0) {
                        sel.add(new Option("No themes found", "", true, true));
                        return;
                    }

                    const readyThemes = themes.filter(t => !IN_PROGRESS_THEMES.includes(t));
                    const inProgressThemes = themes.filter(t => IN_PROGRESS_THEMES.includes(t));
                    const pretty = (t) => t.replace(/_/g, ' ').toUpperCase();

                    if (readyThemes.length > 0) readyThemes.forEach(t => sel.add(new Option(pretty(t), t)));
                    if (inProgressThemes.length > 0) inProgressThemes.forEach(t => sel.add(new Option(pretty(t) + " [WIP]", t)));

                    sel.selectedIndex = 0;
                    updateAvatarGrid(); 
                })
                .catch(e => {
                    console.error(e);
                    document.getElementById('theme-select').innerHTML = '<option>Run asset_generator.py first!</option>';
                });
        }

        // --- AVATAR & SETUP LOGIC ---
        function updateAvatarGrid() {
            const theme = document.getElementById('theme-select').value;
            const safeTheme = theme || 'medieval_classic'; 
            const grid = document.getElementById('avatar-grid');
            grid.innerHTML = '';
            
            const pieces = [
                'w_k', 'w_q', 'w_r', 'w_b', 'w_n', 'w_p',
                'b_k', 'b_q', 'b_r', 'b_b', 'b_n', 'b_p'
            ];
            
            const map = {
                'w_k': 'white_king', 'w_q': 'white_queen', 'w_r': 'white_rook', 'w_b': 'white_bishop', 'w_n': 'white_knight', 'w_p': 'white_pawn',
                'b_k': 'black_king', 'b_q': 'black_queen', 'b_r': 'black_rook', 'b_b': 'black_bishop', 'b_n': 'black_knight', 'b_p': 'black_pawn'
            };

            pieces.forEach(code => {
                const div = document.createElement('div');
                div.className = `avatar-option ${code === selectedAvatar ? 'selected' : ''}`;
                div.onclick = () => {
                    selectedAvatar = code;
                    document.querySelectorAll('.avatar-option').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                };
                
                const img = document.createElement('img');
                img.src = `assets/${safeTheme}/pieces/${map[code]}.png`;
                img.onerror = function() { this.style.opacity = 0.3; }; 
                div.appendChild(img);
                grid.appendChild(div);
            });
        }

        function setupGameCommon() {
            const nameInput = document.getElementById('player-name-input');
            const sel = document.getElementById('theme-select');
            
            if(!sel.value) { alert("Please select a theme first"); return false; }
            if(IN_PROGRESS_THEMES.includes(sel.value)) alert("Note: This theme is WIP.");

            PLAYER_NAME = nameInput.value.trim() || "Commander";
            CURRENT_THEME = sel.value;
            ASSETS_PATH = `assets/${CURRENT_THEME}/`;
            
            document.getElementById('start-menu').classList.remove('active');
            
            // Camera Default
            camera.position.set(0, 60, 80);
            camera.lookAt(0,0,0);
            return true;
        }

        function startGameAI() {
            if(!setupGameCommon()) return;
            initVisuals();
            isMultiplayer = false;
            isAIEnabled = true;
            PLAYER_COLOR = 'w';
            document.getElementById('player-display').innerText = `${PLAYER_NAME} VS AI (CPU)`;
            updateStatus();
        }

        function startGameLocal() {
            if(!setupGameCommon()) return;
            initVisuals();
            isMultiplayer = false;
            isAIEnabled = false;
            PLAYER_COLOR = 'w';
            document.getElementById('player-display').innerText = `LOCAL PVP (HOTSEAT)`;
            updateStatus();
        }
        
        function initVisuals() {
            game.reset();
            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            scene.add(ambientLight);
            scene.add(spotLight);
            buildSimpleBoard();
            initPieces();
        }

        // --- MULTIPLAYER LOGIC ---
        
        function connectSocket() {
            socket = new WebSocket(WS_URL);
            socket.onmessage = (e) => handleNetworkMessage(JSON.parse(e.data));
            socket.onclose = () => { 
                alert("Disconnected."); 
                // Only reload if we aren't already reloading
                if (!window.isReloading) window.location.href = window.location.pathname; 
            };
            return socket;
        }

        function joinLobby() {
            if(!setupGameCommon()) return;
            
            document.getElementById('lobby-menu').classList.add('active');
            updateMyAvatarDisplay();

            isMultiplayer = true;
            isAIEnabled = false;
            
            const ws = connectSocket();
            ws.onopen = () => {
                ws.send(JSON.stringify({ type: 'login', name: PLAYER_NAME, avatar: selectedAvatar }));
            };
        }

        function createPrivateGame() {
            if(!setupGameCommon()) return;

            document.getElementById('invite-menu').classList.add('active');
            isMultiplayer = true;
            isAIEnabled = false;

            const ws = connectSocket();
            ws.onopen = () => {
                ws.send(JSON.stringify({ type: 'create_private', name: PLAYER_NAME, avatar: selectedAvatar }));
            };
        }

        function joinPrivateGame(roomId) {
            // Auto-setup with defaults if via link
            const sel = document.getElementById('theme-select');
            // Wait for themes if needed, but handled in onload promise
            if(!sel.value && sel.options.length > 0) sel.selectedIndex = 0;
            
            setupGameCommon();
            
            isMultiplayer = true;
            isAIEnabled = false;

            const ws = connectSocket();
            ws.onopen = () => {
                ws.send(JSON.stringify({ type: 'join_private', roomId: roomId, name: PLAYER_NAME, avatar: selectedAvatar }));
            };
        }

        function disconnectSocket() {
            if(socket) {
                window.isReloading = true;
                socket.close();
            }
            window.location.href = window.location.pathname; // Clear params
        }
        
        function updateMyAvatarDisplay() {
            const fullMap = {
                'w_k': 'white_king', 'w_q': 'white_queen', 'w_r': 'white_rook', 'w_b': 'white_bishop', 'w_n': 'white_knight', 'w_p': 'white_pawn',
                'b_k': 'black_king', 'b_q': 'black_queen', 'b_r': 'black_rook', 'b_b': 'black_bishop', 'b_n': 'black_knight', 'b_p': 'black_pawn'
            };
            document.getElementById('my-avatar-display').src = `${ASSETS_PATH}pieces/${fullMap[selectedAvatar] || 'white_king'}.png`;
            document.getElementById('my-name-display').innerText = PLAYER_NAME;
        }

        function handleNetworkMessage(msg) {
            if (msg.type === 'login_success') myClientId = msg.myId;
            if (msg.type === 'lobby_update') renderLobbyList(msg.players);
            
            if (msg.type === 'private_created') {
                // Show the link
                const link = `${window.location.protocol}//${window.location.host}${window.location.pathname}?room=${msg.roomId}`;
                document.getElementById('invite-link-box').value = link;
            }

            if (msg.type === 'challenge_received') {
                pendingChallengeId = msg.fromId;
                document.getElementById('challenger-name').innerText = `${msg.fromName} wants to battle!`;
                document.getElementById('challenge-modal').classList.add('active');
            }
            
            if (msg.type === 'error') {
                alert(msg.message);
                disconnectSocket();
            }

            if (msg.type === 'game_start') {
                // Close all menus
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
                
                currentRoomId = msg.roomId;
                PLAYER_COLOR = msg.color;
                
                document.getElementById('player-display').innerText = `VS ${msg.opponent}`;
                
                initVisuals(); // Build board
                
                // Camera
                const isMobile = window.innerWidth < 768;
                const y = isMobile ? 80 : 60;
                const z = (PLAYER_COLOR === 'w') ? (isMobile ? 110 : 80) : (isMobile ? -110 : -80);
                camera.position.set(0, y, z);
                camera.lookAt(0,0,0);
                
                updateStatus();
            }
            if (msg.type === 'move') executeMove(msg.move, true);
            
             if (msg.type === 'opponent_disconnected') {
                alert("Opponent disconnected!");
                triggerGameOver("Opponent Disconnected");
            }
        }

        function renderLobbyList(players) {
            const list = document.getElementById('lobby-list');
            list.innerHTML = '';
            const opponents = players.filter(p => p.id !== myClientId);
            
            if (opponents.length === 0) {
                list.innerHTML = '<li style="padding:20px; text-align:center; color:#666;">Waiting for players...</li>';
                return;
            }
            
            opponents.forEach(p => {
                const li = document.createElement('li');
                li.className = 'player-item';
                
                const fullMap = {
                    'w_k': 'white_king', 'w_q': 'white_queen', 'w_r': 'white_rook', 'w_b': 'white_bishop', 'w_n': 'white_knight', 'w_p': 'white_pawn',
                    'b_k': 'black_king', 'b_q': 'black_queen', 'b_r': 'black_rook', 'b_b': 'black_bishop', 'b_n': 'black_knight', 'b_p': 'black_pawn'
                };
                const avatarUrl = `assets/${CURRENT_THEME}/pieces/${fullMap[p.avatar] || 'white_pawn'}.png`;
                
                li.innerHTML = `
                    <div class="player-info">
                        <img src="${avatarUrl}" style="width:30px; height:30px; object-fit:contain;">
                        <div>
                            <div style="font-weight:bold; color:#fff;">${p.name}</div>
                            <span class="player-stats">W:${p.stats.wins} L:${p.stats.losses}</span>
                        </div>
                    </div>
                    <button class="challenge-btn" onclick="sendChallenge('${p.id}')">FIGHT</button>
                `;
                list.appendChild(li);
            });
        }

        function sendChallenge(targetId) {
            socket.send(JSON.stringify({ type: 'challenge_request', targetId: targetId }));
            alert("Challenge sent!");
        }
        function acceptChallenge() {
            socket.send(JSON.stringify({ type: 'challenge_accept', targetId: pendingChallengeId }));
        }
        function declineChallenge() {
            document.getElementById('challenge-modal').classList.remove('active');
            pendingChallengeId = null;
        }

        // --- GAMEPLAY HELPERS ---
        function buildSimpleBoard() {
            const boardTexture = textureLoader.load(ASSETS_PATH + 'board_texture.png', (tex) => { tex.encoding = THREE.sRGBEncoding; });
            const boardGeo = new THREE.BoxGeometry(84, 1, 84);
            const boardMat = new THREE.MeshStandardMaterial({ map: boardTexture, color: 0xffffff });
            const board = new THREE.Mesh(boardGeo, boardMat);
            board.position.y = -0.5;
            board.receiveShadow = true;
            scene.add(board);
        }

        function squareToVector(square) {
            const file = square.charCodeAt(0) - 97;
            const rank = 8 - parseInt(square[1]);  
            const x = (file * BOARD_SQUARE_SIZE) - BOARD_OFFSET;
            const z = (rank * BOARD_SQUARE_SIZE) - BOARD_OFFSET;
            return new THREE.Vector3(x, 5.5, z);
        }

        function getFullName(type, color) {
            const names = { 'p': 'pawn', 'n': 'knight', 'b': 'bishop', 'r': 'rook', 'q': 'queen', 'k': 'king' };
            const c = color === 'w' ? 'white' : 'black';
            return `${c}_${names[type]}`;
        }

        function loadChromaTexture(name, path, color) {
            if (pieceCache[name]) return pieceCache[name];
            const tex = new THREE.Texture();
            const img = new Image();
            img.src = path;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const d = idata.data;
                for(let i=0; i<d.length; i+=4) {
                    const r=d[i], g=d[i+1], b=d[i+2];
                    if (color === 'w') { if(r < 40 && g < 40 && b < 40) d[i+3] = 0; } 
                    else { if(r > 215 && g > 215 && b > 215) d[i+3] = 0; }
                }
                ctx.putImageData(idata, 0, 0);
                tex.image = canvas; tex.needsUpdate = true; tex.encoding = THREE.sRGBEncoding;
            };
            pieceCache[name] = tex;
            return tex;
        }

        function getTransparentIconUrl(path, color, callback) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = path;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const d = idata.data;
                for(let i=0; i<d.length; i+=4) {
                    const r=d[i], g=d[i+1], b=d[i+2];
                    if (color === 'w') { if(r < 40 && g < 40 && b < 40) d[i+3] = 0; } 
                    else { if(r > 215 && g > 215 && b > 215) d[i+3] = 0; }
                }
                ctx.putImageData(idata, 0, 0);
                callback(canvas.toDataURL());
            };
        }

        function spawnPiece(type, color, square) {
            const fname = getFullName(type, color);
            const path = `${ASSETS_PATH}pieces/${fname}.png`;
            const texture = loadChromaTexture(fname, path, color);
            const geometry = new THREE.PlaneGeometry(11.5, 11.5);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, side: THREE.DoubleSide, depthWrite: false 
            });
            const mesh = new THREE.Mesh(geometry, material);
            const pos = squareToVector(square);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.userData = { type: type, color: color, square: square };
            scene.add(mesh);
            piecesMap[square] = mesh;
        }

        function initPieces() {
            const boardState = game.board();
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = boardState[r][c];
                    if (p) spawnPiece(p.type, p.color, String.fromCharCode(97 + c) + (8 - r));
                }
            }
        }

        function updateCaptures(capturedPiece, capturerColor) {
            const fullPieceName = getFullName(capturedPiece, capturerColor === 'w' ? 'b' : 'w');
            const iconPath = `${ASSETS_PATH}pieces/${fullPieceName}.png`;
            const pieceColor = capturerColor === 'w' ? 'b' : 'w';
            
            getTransparentIconUrl(iconPath, pieceColor, (dataUrl) => {
                const img = document.createElement('img');
                img.src = dataUrl;
                img.className = 'capture-icon';
                const containerId = capturerColor === 'w' ? 'tracker-w' : 'tracker-b';
                document.getElementById(containerId).appendChild(img);
            });
        }

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const inputState = { isPointerDown: false, startX: 0, startY: 0 };

        renderer.domElement.addEventListener('pointerdown', (e) => {
            if (e.button !== undefined && e.button !== 0) return;
            inputState.isPointerDown = true;
            inputState.startX = e.clientX;
            inputState.startY = e.clientY;
        });

        renderer.domElement.addEventListener('pointerup', (e) => {
            if (!inputState.isPointerDown) return;
            inputState.isPointerDown = false;
            const dist = Math.sqrt(Math.pow(e.clientX - inputState.startX, 2) + Math.pow(e.clientY - inputState.startY, 2));
            if (dist < 10) onInteraction(e.clientX, e.clientY);
        });

        function onInteraction(clientX, clientY) {
            if(document.getElementById('battle-overlay').style.display === 'flex') return;
            
            // IF AI is enabled, block input when it's not my turn
            if(isAIEnabled && game.turn() !== PLAYER_COLOR) return;
            // IF Multiplayer, block input if not my turn
            if(isMultiplayer && game.turn() !== PLAYER_COLOR) return;
            // IF Local PvP, we allow both turns
            
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const pieceIntersects = raycaster.intersectObjects(Object.values(piecesMap));
            if (pieceIntersects.length > 0) {
                const mesh = pieceIntersects[0].object;
                const square = mesh.userData.square;
                if (game.get(square).color === game.turn()) { selectPiece(square); return; }
                else if (selectedSquare) { attemptMove(square); return; }
            }

            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            if (target && selectedSquare) {
                const fileIdx = Math.floor((target.x + BOARD_OFFSET + BOARD_SQUARE_SIZE/2) / BOARD_SQUARE_SIZE);
                const rankIdx = Math.floor((target.z + BOARD_OFFSET + BOARD_SQUARE_SIZE/2) / BOARD_SQUARE_SIZE);
                if (fileIdx >= 0 && fileIdx < 8 && rankIdx >= 0 && rankIdx < 8) {
                    attemptMove(String.fromCharCode(97 + fileIdx) + (8 - rankIdx));
                }
            }
        }

        function selectPiece(square) {
            if (selectedMesh) selectedMesh.material.color.setHex(0xffffff);
            selectedSquare = square;
            selectedMesh = piecesMap[square];
            if (selectedMesh) selectedMesh.material.color.setHex(0x00ff00);
        }

        function attemptMove(targetSquare) {
            const piece = game.get(selectedSquare);
            if (piece.type === 'p' && (targetSquare[1] === '8' || targetSquare[1] === '1')) {
                const tempMove = new Chess(game.fen());
                const valid = tempMove.move({from:selectedSquare, to:targetSquare, promotion:'q'});
                if(valid) {
                    pendingPromotionMove = { from: selectedSquare, to: targetSquare };
                    document.getElementById('promo-modal').classList.add('active');
                    return;
                }
            }
            executeMove({ from: selectedSquare, to: targetSquare, promotion: 'q' });
        }

        function commitPromotion(promotionPiece) {
            document.getElementById('promo-modal').classList.remove('active');
            if (pendingPromotionMove) {
                executeMove({ 
                    from: pendingPromotionMove.from, 
                    to: pendingPromotionMove.to, 
                    promotion: promotionPiece 
                });
                pendingPromotionMove = null;
            }
        }

        function executeMove(moveObj, isNetworkMove = false) {
            let move;
            if (isNetworkMove) {
                move = game.move(moveObj);
            } else {
                move = game.move(moveObj);
            }

            if (move) {
                if(selectedMesh) selectedMesh.material.color.setHex(0xffffff);
                selectedSquare = null; selectedMesh = null;
                
                // Send to Server if MP
                if (isMultiplayer && !isNetworkMove && socket) {
                    socket.send(JSON.stringify({ type: 'move', roomId: currentRoomId, move: moveObj }));
                }
                
                handleMoveVisuals(move, () => {
                    updateStatus();
                    
                    if (game.in_checkmate() || game.in_draw()) {
                        if(game.in_checkmate()) {
                            playCheckmateAnimation(move);
                            if(isMultiplayer && !isNetworkMove && socket) {
                                 socket.send(JSON.stringify({
                                    type: 'game_over',
                                    winnerName: game.turn() === 'w' ? 'Black' : 'White',
                                    loserName: game.turn() === 'w' ? 'White' : 'Black'
                                }));
                            }
                        } else {
                            triggerGameOver();
                        }
                    } else if(!game.game_over()) {
                        // AI LOGIC
                        if(isAIEnabled && game.turn() !== PLAYER_COLOR) {
                            isAIThinking = true;
                            document.getElementById('status').innerText = "AI is thinking...";
                            setTimeout(makeAIMove, 800);
                        }
                    }
                });
            }
        }

        function makeAIMove() {
            const moves = game.moves({ verbose: true });
            if (moves.length === 0) return;
            
            let bestMove = moves[Math.floor(Math.random() * moves.length)];
            const captures = moves.filter(m => m.captured);
            if (captures.length > 0) bestMove = captures[Math.floor(Math.random() * captures.length)];
            
            if (bestMove.promotion) bestMove.promotion = 'q';

            game.move(bestMove);
            handleMoveVisuals(bestMove, () => {
                isAIThinking = false;
                updateStatus();
                if (game.in_checkmate() || game.in_draw()) {
                    if (game.in_checkmate()) playCheckmateAnimation(bestMove);
                    else triggerGameOver(game.in_draw() ? "Draw" : "Game Over");
                }
            });
        }

        // --- ANIMATIONS & VISUALS ---
        function handleMoveVisuals(move, onComplete) {
            const originSquare = move.from;
            const destSquare = move.to;
            const pieceMesh = piecesMap[originSquare];
            const targetPos = squareToVector(destSquare);

            if (move.captured) updateCaptures(move.captured, move.color);

            if (move.flags.includes('k') || move.flags.includes('q')) {
                let rookSrc, rookDst;
                if (move.color === 'w') {
                    rookSrc = move.flags.includes('k') ? 'h1' : 'a1';
                    rookDst = move.flags.includes('k') ? 'f1' : 'd1';
                } else {
                    rookSrc = move.flags.includes('k') ? 'h8' : 'a8';
                    rookDst = move.flags.includes('k') ? 'f8' : 'd8';
                }
                const rookMesh = piecesMap[rookSrc];
                const rookPos = squareToVector(rookDst);
                finishMove(rookMesh, rookPos, rookSrc, rookDst, null);
            }

            if (move.captured) {
                playKillVideo(move, () => {
                    const victimMesh = piecesMap[destSquare];
                    if(victimMesh) scene.remove(victimMesh);
                    if (move.promotion) {
                        scene.remove(pieceMesh);
                        spawnPiece(move.promotion, move.color, originSquare);
                        const newMesh = piecesMap[originSquare];
                        finishMove(newMesh, targetPos, originSquare, destSquare, onComplete);
                    } else {
                        finishMove(pieceMesh, targetPos, originSquare, destSquare, onComplete);
                    }
                });
            } else {
                if (move.promotion) {
                    scene.remove(pieceMesh);
                    spawnPiece(move.promotion, move.color, originSquare);
                    const newMesh = piecesMap[originSquare];
                    finishMove(newMesh, targetPos, originSquare, destSquare, onComplete);
                } else {
                    finishMove(pieceMesh, targetPos, originSquare, destSquare, onComplete);
                }
            }
        }

        function finishMove(mesh, targetPos, oldSquare, newSquare, onComplete) {
            new TWEEN.Tween(mesh.position)
                .to({ x: targetPos.x, z: targetPos.z }, 400)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => { if (onComplete) onComplete(); })
                .start();
            delete piecesMap[oldSquare];
            piecesMap[newSquare] = mesh;
            mesh.userData.square = newSquare;
        }

        function updateStatus() {
            let status = '';
            let moveColor = game.turn() === 'w' ? 'White' : 'Black';
            const statEl = document.getElementById('status');
            const alertEl = document.getElementById('check-alert');
            
            statEl.classList.remove('check');
            alertEl.style.display = 'none';
            
            Object.values(piecesMap).forEach(p => p.material.color.setHex(0xffffff));
            if (game.in_check()) {
                statEl.classList.add('check');
                alertEl.style.display = 'block';
                setTimeout(() => { alertEl.style.display = 'none'; }, 2500);
                
                const turn = game.turn();
                const board = game.board();
                for(let r=0; r<8; r++) {
                    for(let c=0; c<8; c++) {
                        const p = board[r][c];
                        if (p && p.type === 'k' && p.color === turn) {
                            const sq = String.fromCharCode(97 + c) + (8 - r);
                            if(piecesMap[sq]) piecesMap[sq].material.color.setHex(0xff0000);
                        }
                    }
                }
            }

            if (game.in_checkmate()) status = 'CHECKMATE! ' + (moveColor==='White'?'Black':'White') + ' WINS!';
            else if (game.in_draw()) status = 'Game over, drawn position';
            else {
                status = moveColor + ' to move';
                if (game.in_check()) status += ' (CHECK!)';
            }
            statEl.innerText = status;
        }

        function triggerGameOver(manualReason) {
            let reason = manualReason || "Game Over";
            if(!manualReason) {
                if(game.in_checkmate()) {
                    const winner = game.turn() === 'w' ? "BLACK" : "WHITE";
                    reason = `CHECKMATE - ${winner} WINS!`;
                } else if(game.in_draw()) {
                    reason = "DRAW (Stalemate / Insufficient Material)";
                }
            }
            document.getElementById('end-title').innerText = reason;
            document.getElementById('end-reason').innerText = `Well fought, ${PLAYER_NAME}.`;
            setTimeout(() => { document.getElementById('game-over-modal').classList.add('active'); }, 1000);
        }

        // --- VIDEO ---
        const overlay = document.getElementById('battle-overlay');
        const vid = document.getElementById('battle-video');
        const msg = document.getElementById('video-msg');
        const skip = document.getElementById('skip-btn');
        let onVideoEnd = null;

        skip.onclick = stopVideo;

        function playKillVideo(move, callback) {
            const attackerColor = move.color === 'w' ? 'white' : 'black';
            const victimColor = move.color === 'w' ? 'black' : 'white';
            const attackerPiece = getFullName(move.piece, move.color).split('_')[1];
            const victimPiece = getFullName(move.captured, move.color === 'w' ? 'b' : 'w').split('_')[1];
            playVideoFile(`${attackerColor}_${attackerPiece}_takes_${victimColor}_${victimPiece}.mp4`, callback);
        }

        function playCheckmateAnimation(move) {
            const attackerColor = move.color === 'w' ? 'white' : 'black';
            const victimColor = move.color === 'w' ? 'black' : 'white';
            const attackerPiece = getFullName(move.piece, move.color).split('_')[1];
            playVideoFile(`${attackerColor}_${attackerPiece}_takes_${victimColor}_king.mp4`, () => triggerGameOver());
        }

        function playVideoFile(filename, callback) {
            onVideoEnd = callback;
            const fullPath = `${ASSETS_PATH}videos/${filename}`;
            msg.innerText = `Loading: ${filename}`;
            vid.src = fullPath;
            overlay.style.display = 'flex';
            vid.play().then(() => { msg.innerText = ""; }).catch(e => {
                msg.innerText = `VIDEO MISSING: ${filename}`;
                setTimeout(stopVideo, 1000);
            });
            vid.onended = stopVideo;
        }

        function stopVideo() {
            vid.pause();
            overlay.style.display = 'none';
            if (onVideoEnd) { onVideoEnd(); onVideoEnd = null; }
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            for (let key in piecesMap) {
                const mesh = piecesMap[key];
                mesh.lookAt(camera.position.x, mesh.position.y, camera.position.z);
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>